Enumeration is the key to privilege escalation. Several helper scripts (such as [LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS) and [LinEnum](https://github.com/rebootuser/LinEnum)) exist to assist with enumeration.
### Things to look for:
- Basic System Enumeration
- Bash History
- OpenVPN Credentials
- Credentials in tcpdump files
- Writable Files
- SSH Private Keys
- Kernel Expliots
- Sudo -l
- Sudo CVE
- Sudo LD_PRELOAD
- SUID / GUID Binaries
- SUID PATH Environmental Variable
- Cron Tabs & Scheduled Tasks
- Capabilities (Python - Perl - Tar - OpenSSL)
- NFS Root Squashing
- chkrootkit 0.49
- Tmux (Attach Session)
- Screen (Attach Session)
- MySQL Running as root
- MySQL UDF (User-Defined Functions) Code (UDF) Injection
- Sudo Injection (Sudo Token)
- LXD (Container & Alphine Image)
- docker
- kubernetes
- ADM group
- linux Capabilities
----
## LinEnum
https://github.com/rebootuser/LinEnum
## linpeas
## foothold commands
These are the fastest, highest-value commands. Run them first and _capture output_ to your notes.

```
whoami
id
hostname
uname -a
sudo -l
env
echo $PATH
ip a || ifconfig
cat /etc/hosts
cat /etc/os-release
ps aux --sort=-%cpu | head -n 20
w || who
lastlog
```

`whoami` - what user are we running as
- `id` - what groups does our user belong to?
- `hostname` - what is the server named, can we gather anything from the naming convention?
- `ifconfig` or `ip a` - what subnet did we land in, does the host have additional NICs in other subnets?
- `sudo -l` - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like `sudo su` and drop right into a root shell.
## Easy wins (no exploit required)

Order these from fastest to slightly more effort.

1. **Sudo misconfigurations** — `sudo -l` (look for `NOPASSWD` and odd `Cmnd_Alias`).
    
2. **Readable secrets** — `grep -R --line-number -i "pass\|pwd\|secret\|token" /etc /home 2>/dev/null`.
    
3. **Accessible SSH keys** — `find / -type f -name "id_rsa*" 2>/dev/null` and check permissions/contents.
    
4. **World-writable dirs / files in privileged paths** — `find / -writable -type f 2>/dev/null` and suspicious writable dirs in `/etc`, `/usr/local/bin`, etc.
    
5. **Credentials in config files** — check `/etc/*conf`, `/var/www`, backup files, `.env` files, and database config files.
---
## Files & credential discovery (systematic)

Aim to find plaintext credentials, private keys, backups, and leftover files.

```bash
# passwd / groups / shells
cut -d: -f1 /etc/passwd
getent group
grep "sh$" /etc/passwd
cat /etc/group

# Search for common secrets and backups
sudo find / -type f \( -iname "*.bak" -o -iname "*.backup" -o -iname "*.old" \) -perm -o+r 2>/dev/null
sudo find / -type f -name "*.env" -o -name "*.conf" 2>/dev/null | xargs -r grep -iH "pass\|pwd\|secret\|key" 2>/dev/null

# History files (may require root to read some users')
find / -type f \( -name "*_history" -o -name ".bash_history" -o -name ".zsh_history" \) -exec ls -l {} \; 2>/dev/null

# Search for private keys
find / -type f \( -name "id_rsa" -o -name "id_dsa" -o -name "*.pem" \) 2>/dev/null -exec ls -l {} \;
```

**Pro tip:** search for credential-like patterns inside backup/old files (e.g., `grep -R "password" /var/www 2>/dev/null`).

---
## Services, daemons & misconfigurations

Check running services and how they run (which user, config paths):

```bash
ss -tulpen
netstat -tulpen
ps -eo pid,user,cmd --sort=user | grep -iE "nginx|apache|mysql|postgres|docker|sshd|cron|systemd"
ls -l /etc/systemd/system /lib/systemd/system
systemctl list-timers --all
```


Look for:

- Services running as `root` that load configs from writable locations.
    
- Services that execute scripts in world-writable directories.
    
- Database services with local socket or credentials readable by attacker.

## Scheduled tasks & scripts (cron, systemd timers)

Cron is a very common vector.

```bash
# retrieve cron entries
ls -la /etc/cron.*
crontab -l 2>/dev/null || true
for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l 2>/dev/null; done
systemctl list-timers --all
find /etc/systemd -type f -name "*.service" -exec grep -H "Exec" {} \; 

# os info
We'll start out by checking out what operating system and version we are dealing with.


## path
if the PATH variable for a target user is misconfigured we may be able to leverage it to escalate privileges. For now we'll note it down and add it to our notetaking tool of choice.
```shell-session
echo $PATH
```

## Environment, PATH & shell pitfalls
We can also check out all environment variables that are set for our current user, we may get lucky and find something sensitive in there such as a password.

A misconfigured `PATH` or environment variables can allow hijacking.

```bash
echo $PATH
env | sort
grep -R "LD_PRELOAD\|LD_LIBRARY_PATH\|PYTHONPATH" /etc/profile /etc/bash* /home/*/.bash* 2>/dev/null
```

- If `$PATH` contains `.` or a writable dir before system binaries, you can place a malicious executable with a common name (e.g., `ls`) and get code run by sudoed commands.
    
- Check for writable shell initialization files (`.bashrc`, `.profile`) of privileged users.
- ---
## Kernel & package vulnerabilities (last resort)

After enumeration, check installed kernel and package versions and compare against public advisories (careful — this may need online checks).

```bash
uname -r
dpkg -l | grep -E "sudo|systemd|bash|kernel|glibc" || rpm -qa | grep -E "sudo|systemd|bash|kernel|glibc"
sudo -V
```

Only attempt local kernel exploits when other paths are exhausted. Keep notes of exact version strings for exploit selection.

## Containers & virtualization escape

If running inside a container check:

```bash
cat /proc/1/cgroup
ls -la /.dockerenv 2>/dev/null
find / -maxdepth 2 -name "docker" -o -name "k8s" 2>/dev/null
```

Look for mounted host directories (`/host`, `/proc/1/root` symlinks), Docker socket access (`/var/run/docker.sock`), or privileged mounts. Those are often easier than kernel exploits.

---
## Users
All users on the system are stored in the `/etc/passwd` file. The format gives us some information, such as:
```shell-session
$ cat /etc/passwd | cut -f1 -d:
```
1. Username
2. Password
3. User ID (UID)
4. Group ID (GID)
5. User ID info
6. Home directory
7. - Shell
## /etc/passwd
Occasionally, we will see password hashes directly in the `/etc/passwd` file. This file is readable by all users, and as with hashes in the `/etc/shadow` file, these can be subjected to an offline password cracking attack.

list of hash algorithms on the password


|**Algorithm**|**Hash**|
|---|---|
|Salted MD5|`$1$`...|
|SHA-256|`$5$`...|
|SHA-512|`$6$`...|
|BCrypt|`$2a$`...|
|Scrypt|`$7$`...|
|Argon2|`$argon2i$`...|

We'll also want to check which users have login shells. Once we see what shells are on the system, we can check each version for vulnerabilities. Because outdated versions, such as Bash version 4.1, are vulnerable to a `shellshock` exploit.
```shell-session
grep "sh$" /etc/passwd
```
## groups
Each user in Linux systems is assigned to a specific group or groups and thus receives special privileges. For example, if we have a folder named `dev` only for developers, a user must be assigned to the appropriate group to access that folder.
```shell-session
$ cat /etc/group
```
list group members
```shell-session
$ getent group sudo
```

## CPU
information about the host itself such as the CPU type/version:

```shell-session
$ lscpu 
```

## SHELL TYPES
What login shells exist on the server? Note these down and highlight that both `Tmux` and `Screen `are available to us.

```shell-session
cat /etc/shells
```

## Drives
Next we can take a look at the drives and any shares on the system. If we discover and can mount an additional drive or unmounted file system, we may find sensitive files, passwords, or backups that can be leveraged to escalate privileges.
```shell-session

lsblk
df -h
cat /etc/fstab
mount
showmount -e localhost 2>/dev/null || true
```
Search `/etc/fstab` for credentials or mounts pointing to network shares; check for old/backup disks under `/mnt` or `/media`.

if we can extend our privileges to the `root` user, we could mount and read these file systems ourselves. Unmounted file systems can be viewed as follows:

```shell-session
cat /etc/fstab | grep -v "#" | column -t
```

# fstabs

 Can we mount an umounted drive and gain access to sensitive data? 
 Can we find any types of credentials in `fstab` for mounted drives by grepping for common words such as password, username, credential, etc in `/etc/fstab`?
 ```shell-session
$ cat /etc/fstab
```
# routing table
Check out the routing table by typing `route` or `netstat -rn`. Here we can see what other networks are available via which interface.
```shell-session
route
```

##  Recent communications with other hosts
We'll also want to check the arp table to see what other hosts the target has been communicating with.
```shell-session
arp -a
```


## Networking & domain environment clues

If the host is part of a domain, internal DNS or Kerberos configs can be used.

```bash
cat /etc/resolv.conf
arp -a
route -n || ip route

# If AD-aware: check SSSD, samba, winbind configs
cat /etc/sssd/sssd.conf 2>/dev/null
cat /etc/samba/smb.conf 2>/dev/null
```
## printers
The command `lpstat` can be used to find information about any printers attached to the system. If there are active or queued print jobs can we gain access to some sort of sensitive information?


## Hidden files
`with regex` USE THIS ONE:
```
sudo find / -type f -name "*.sh" -exec grep -H "pass" {} + 2>/dev/null
```

`this one was provided in the module section but it didnt actually find anything useful...`
```shell-session
 find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep pass
```
## hidden diretories

```shell-session
find / -type d -name ".*" -ls 2>/dev/null
```

## Internals

When we talk about the `internals`, we mean the internal configuration and way of working, including integrated processes designed to accomplish specific tasks. So we start with the interfaces through which our target system can communicate.


```shell-session
ip a
```
## sudo version
It's also a good idea to check if the `sudo` version installed on the system is vulnerable to any legacy or recent exploits.
```shell-session
sudo -V

Sudo version 1.8.31
```

`Hosts`
```shell-session
cat /etc/hosts
```
## Binaries: SUID, capabilities, and interesting executables
Occasionally it can also happen that no direct packages are installed on the system but compiled programs in the form of binaries. These do not require installation and can be executed directly by the system itself.

```bash
# SUID files
find / -perm -4000 -type f 2>/dev/null

# Capabilities
getcap -r / 2>/dev/null

# Check common paths for suspicious/writable executables
ls -l  /bin /usr/bin /usr/sbin /usr/local/bin /opt /home/*/bin 2>/dev/null

# List of packages to match GTFOBins (installed packages)
# (generate installed package list then check against GTFOBins list)
```

## installed packages
 `Installed packages`
```shell-session
$ apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list
```
## GTFOBINS and SUID BInaries
search packages for gtfobins binaries #gtfobins #gtfo-privesc

` Match  package list with GFTOBINS`
```shell-session
$ for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done

Check GTFO for: ab                                         
Check GTFO for: apt                                        
Check GTFO for: ar                                         
Check GTFO for: as         
Check GTFO for: ash                                        
Check GTFO for: aspell                                     
Check GTFO for: at     
Check GTFO for: awk      
```
=================================================================
### TRACE SYSTEM CALLS
We can use the diagnostic tool `strace` on Linux-based operating systems to track and analyze system calls and signal processing. It allows us to follow the flow of a program and understand how it accesses system resources, processes signals, and receives and sends data from the operating system. In addition, we can also use the tool to monitor security-related activities and identify potential attack vectors, such as specific requests to remote hosts using passwords or tokens.

The output of `strace` can be written to a file for later analysis, and it provides a wealth of options that allow detailed monitoring of the program's behavior.
```shell-session
$ strace ping -c1 10.129.112.20 |tee -a trace-ping.txt
```

## PROC FS
The [proc filesystem](https://man7.org/linux/man-pages/man5/proc.5.html) (`proc` / `procfs`) is a particular filesystem in Linux that contains information about system processes, hardware, and other system information. It is the primary way to access process information and can be used to view and modify kernel settings. It is virtual and does not exist as a real filesystem but is dynamically generated by the kernel. It can be used to look up system information such as the state of running processes, kernel parameters, system memory, and devices. It also sets certain system parameters, such as process priority, scheduling, and memory allocation.

```shell-session
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"
```
=========================================================

`cronjobs`
```shell-session
$ ls -la /etc/cron.daily/
```

`CONFIG FILES`
```shell-session
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null
```

`Scripts`
```shell-session
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"
```
#### Running Services by User
Also, if we look at the process list, it can give us information about which scripts or binaries are in use and by which user. So, for example, if it is a script created by the administrator in his path and whose rights have not been restricted, we can run it without going into the `root` directory.
`check for scripts/whatever is running as root`
```shell-session
$ ps aux | grep root
```

`Finding History Files`
```shell-session
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null

-rw------- 1 htb-student htb-student 387 Nov 2
```

`Logged In Users`
```shell-session
w

 12:27:21 up 1 day, 16:55,  1 user,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
cliff.mo pts/0    10.10.14.16      Tue19   40:54m  0.02s  0.02s -bash
````


It can also be helpful to check out each user's last login time to try to see when users typically log in to the system and how frequently. This can give us an idea of how widely used this system is which can open up the potential for more misconfigurations or "messy" directories or command histories.
`check last login`
```shell-session
lastlog

Username         Port     From             Latest
root                                       **Never logged in**
daemon                                     **Never logged in**
bin                                        **Never logged in**
sys                                        **Never logged in**
sync                                       **Never logged in**
...SNIP...
systemd-coredump                           **Never logged in**
mrb3n            pts/1    10.10.14.15      Tue Aug  2 19:33:16 +0000 2022
lxd                                        **Never logged in**
bjones                                     **Never logged in**
administrator.ilfreight                           **Never logged in**
backupsvc                                  **Never logged in**
cliff.moore      pts/0    127.0.0.1        Tue Aug  2 19:32:29 +0000 2022
```